#include <SFML/Graphics.hpp>
#include <SFML/Window.hpp>
#include <Cassert>

struct Vector2f
{
    float x;
    float y;
};

struct Sphere
{
    Vector2f position;
    Vector2f velocity;
    Vector2f acceleration;
    int radius;
    int red;
    int green;
    int blue;
    int m;
};

void drawSphere(sf::RenderWindow* window, Sphere sphere)
{
    int numberofCircles = 100;
    float x_centerofCircles = sphere.position.x;
    float y_centerofCircles = sphere.position.y;
    sf::CircleShape circle(0, 30);

    for (int i = 0; i < numberofCircles; i++)
    {
        circle.setRadius(sphere.radius - i * sphere.radius / numberofCircles);
        circle.setFillColor(sf::Color(i * sphere.red / numberofCircles, i * sphere.green / numberofCircles, i * sphere.blue / numberofCircles));
        circle.setPosition(sphere.position.x + (sphere.position.x - x_centerofCircles) * i / numberofCircles  - sphere.radius + sphere.radius*i/ numberofCircles, sphere.position.y + (sphere.position.y - y_centerofCircles) * i / numberofCircles - sphere.radius + sphere.radius * i / numberofCircles);
        window->draw(circle);
    }
}

void moveSphere(Sphere* sphere, int t)
{
    sphere->position.x = sphere->position.x + sphere->velocity.x * t;
    sphere->position.y = sphere->position.y + sphere->velocity.y * t;
}

void collideSphereWall(Sphere* sphere, int windowX, int windowY, int t)
{
    if (sphere->position.x + sphere->radius + sphere->velocity.x * t > windowX)
    {
        sphere->velocity.x = -abs(sphere->velocity.x);
        sphere->position.x = sphere->position.x + 2 * (windowX - sphere->position.x) - 2 * sphere->radius;
    }

    if (sphere->position.x + sphere->velocity.x * t - sphere->radius < 0)
    {
        sphere->velocity.x = abs(sphere->velocity.x);
        sphere->position.x = -sphere->position.x + 2 * sphere->radius;
    }
    if (sphere->position.y + sphere->radius + sphere->velocity.y * t > windowY)
    {
        sphere->velocity.y = -abs(sphere->velocity.y);
        sphere->position.y = sphere->position.y + 2 * (windowY - sphere->position.y) - 2 * sphere->radius;
    }
    if (sphere->position.y + sphere->velocity.y * t - sphere->radius < 0)
    {
        sphere->velocity.y = abs(sphere->velocity.y);
        sphere->position.y = -sphere->position.y + 2 * sphere->radius;
    }
}

bool checkCollisionTwoSphers(Sphere sphere1, Sphere sphere2)
{
    return (pow(sphere2.position.x - sphere1.position.x, 2) + pow(sphere2.position.y - sphere1.position.y, 2) < pow(sphere1.radius + sphere2.radius, 2));
}

void collideTwoSphers(Sphere* sphere1, Sphere* sphere2, int t, int windowX, int windowY)
{
    float dv1 = sphere1->velocity.x;
    float du1 = sphere1->velocity.y;
    float dv2 = sphere2->velocity.x;
    float du2 = sphere2->velocity.y;

    float x1 = sphere1->position.x;
    float y1 = sphere1->position.y;
    float x2 = sphere2->position.x;
    float y2 = sphere2->position.y;

    float dist = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
    sphere1->position.x = sphere1->position.x + (sphere1->radius + sphere2->radius - dist) * (x1 - x2) / (2 * dist);
    sphere1->position.y = sphere1->position.y + (sphere1->radius + sphere2->radius - dist) * (y1 - y2) / (2 * dist);
    sphere2->position.x = sphere2->position.x + (sphere1->radius + sphere2->radius - dist) * (x2 - x1) / (2 * dist);
    sphere2->position.y = sphere2->position.y + (sphere1->radius + sphere2->radius - dist) * (y2 - y1) / (2 * dist);

    if ((x1 + sphere1->radius + sphere1->velocity.x * t > windowX) or (x1 + sphere1->velocity.x * t - sphere1->radius < 0))
    {
        sphere2->position.x = sphere2->position.x + (sphere1->radius + sphere2->radius - dist) * (x2 - x1) / dist;
    }

    if ((x2 + sphere2->radius + sphere2->velocity.x * t > windowX) or (x2 + sphere1->velocity.x * t - sphere1->radius < 0))
    {
        sphere1->position.x = sphere1->position.x + (sphere1->radius + sphere2->radius - dist) * (x1 - x2) / dist;
        sphere2->position.x = x2;
    }
    if ((y1 + sphere1->radius + sphere1->velocity.y * t > windowY) or (y1 + sphere1->velocity.y * t - sphere1->radius < 0))
    {
        sphere2->position.y = sphere2->position.y + (sphere1->radius + sphere2->radius - dist) * (y2 - y1) / dist;
    }

    if ((y2 + sphere2->radius + sphere2->velocity.y * t > windowY) or (y2 + sphere1->velocity.y * t - sphere1->radius < 0))
    {
        sphere1->position.y = sphere1->position.y + (sphere1->radius + sphere2->radius - dist) * (y1 - y2) / dist;
        sphere2->position.y = y2;
    }

    sphere1->velocity.x = (2 * sphere2->m * dv2 + (sphere1->m - sphere2->m) * dv1) / (sphere1->m + sphere2->m);
    sphere1->velocity.y = (2 * sphere2->m * du2 + (sphere1->m - sphere2->m) * du1) / (sphere1->m + sphere2->m);
    sphere2->velocity.x = (2 * sphere1->m * dv1 + (sphere2->m - sphere1->m) * dv2) / (sphere1->m + sphere2->m);
    sphere2->velocity.y = (2 * sphere1->m * du1 + (sphere2->m - sphere1->m) * du2) / (sphere1->m + sphere2->m);

    assert(dist);
}

void changeVelocity(Sphere* sphere, int t)
{
    sphere->velocity.x = sphere->velocity.x + sphere->acceleration.x * t;
    sphere->velocity.y = sphere->velocity.y + sphere->acceleration.y * t;
}

int main()
{
    int t = 1;
    int windowX = 1200;
    int windowY = 800;

    Sphere particles[100];
    for (int i = 0; i < 100; i++)
        {
            particles[i] = { float((i + 1) * 25 % 1000), float((i + 1) * 25 / 10), 5, 5,  0, 0, 10, 255, 255, 0, 1 };
        }
    
    sf::RenderWindow window(sf::VideoMode(windowX, windowY), "Window");

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
            {
                window.close();
            }
        }

        for (int i = 0; i < 100; i++)
        {
            for (int j = i + 1; j < 100; j++)
            {
                if (checkCollisionTwoSphers(particles[i], particles[j]))
                {
                    collideTwoSphers(&particles[i], &particles[j], t, windowX, windowY);
                }
            }
        }

        for (int i = 0; i < 100; i++)
        {
            collideSphereWall(&particles[i], windowX, windowY, t);
        }
        
        for (int i = 0; i < 100; i++)
        {
            moveSphere(&particles[i], t);
        }
        
        window.clear();
        for (int i = 0; i < 100; i++)
        {
            assert((particles[i].position.x >= 0) and (particles[i].position.x <= windowX) and (particles[i].position.y >= 0) and (particles[i].position.y <= windowY));
            drawSphere(&window, particles[i]);
        }
        window.display();
    }

    return 0;
}
